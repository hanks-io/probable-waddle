// node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function isObservable(x) {
  return typeof x === "object" && x !== null && "subscribe" in x;
}
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          var _a;
          if (isDone) {
            return;
          }
          (_a = observer.next) == null ? void 0 : _a.call(observer, value);
        },
        error(err) {
          var _a;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a = observer.error) == null ? void 0 : _a.call(observer, err);
          unsubscribe();
        },
        complete() {
          var _a;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a = observer.complete) == null ? void 0 : _a.call(observer);
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}

// node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          var _a;
          for (const observer of observers) {
            (_a = observer.next) == null ? void 0 : _a.call(observer, value);
          }
        },
        error(error) {
          var _a;
          for (const observer of observers) {
            (_a = observer.error) == null ? void 0 : _a.call(observer, error);
          }
        },
        complete() {
          var _a;
          for (const observer of observers) {
            (_a = observer.complete) == null ? void 0 : _a.call(observer);
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v) => v === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
function map(project) {
  return (originalObserver) => {
    return {
      subscribe(observer) {
        let index = 0;
        const subscription = originalObserver.subscribe({
          next(value) {
            var _a;
            (_a = observer.next) == null ? void 0 : _a.call(observer, project(value, index++));
          },
          error(error) {
            var _a;
            (_a = observer.error) == null ? void 0 : _a.call(observer, error);
          },
          complete() {
            var _a;
            (_a = observer.complete) == null ? void 0 : _a.call(observer);
          }
        });
        return subscription;
      }
    };
  };
}
function tap(observer) {
  return (originalObserver) => {
    return {
      subscribe(observer2) {
        return originalObserver.subscribe({
          next(v) {
            var _a, _b;
            (_a = observer.next) == null ? void 0 : _a.call(observer, v);
            (_b = observer2.next) == null ? void 0 : _b.call(observer2, v);
          },
          error(v) {
            var _a, _b;
            (_a = observer.error) == null ? void 0 : _a.call(observer, v);
            (_b = observer2.error) == null ? void 0 : _b.call(observer2, v);
          },
          complete() {
            var _a, _b;
            (_a = observer.complete) == null ? void 0 : _a.call(observer);
            (_b = observer2.complete) == null ? void 0 : _b.call(observer2);
          }
        });
      }
    };
  };
}
var ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}

export {
  isObservable,
  observable,
  share,
  map,
  tap,
  observableToPromise
};
//# sourceMappingURL=chunk-XLKTPKW7.js.map
